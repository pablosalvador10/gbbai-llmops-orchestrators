{"messages": [{"role": "system", "content": "Question: I'm attempting to do Jitter measurements on a low frequency DUT clock with the UP1600. There's a lot of variables to control, and I keep getting Jitter measurements that are smaller than actual (using a scope). What's a guideline to how I should program the Jitter Variables?"}, {"role": "user", "content": "Assuming you have already created an infinitely looping pattern to get a desired repeating output signal, here are some guidelines on jitter variables: 1. The bit period should be set to be equal to the DUT output period. For clocks, even for non 50% Duty Cycle clocks, set the bit period to 1/2 of the clock period. 2. The Bits per Pattern should be set to 2 for a clock. 3. A good starting value for TargetPatternReps is 250/number of bits per pattern (rounded-up). For Clocks you should aim for an even higher value to avoid sampling fast enough that low frequency jitter is eliminated 4. TargetResolution should be <=1/6 Rj, where Rj is the expected value of the Randomized Jitter. depending on the setup Rj may be comparable to the TIE spec of a DUT Clock. Select an effective TargetResolution and a large TargetPatternReps. Verify that the measured jitter is close to the expected value. Iteratively decrease the TargetPatternReps until you notice the measure jitter starts to drop. This represents a variable set that could be ideal for measuring your specific DUT clock that is also time-efficient. Repeat with several different resolutions and compare test times to find an ideal jitter variable set."}]}
{"messages": [{"role": "system", "content": "Question: How do I get a current profile of my entire flow?"}, {"role": "user", "content": "Due to the limited memory on DCVI and DCVS instruments, this operation will need to be completed in multiple profiles that are stitched together after the flow is complete. You can download a class module off of eKnowledge and add it to your IGXL program. Then, you can wrap your test code either in VBT or on the flow sheet. At the end of the flow, export your profile as a .txt or a .wave file using the included function. You can find detailed instructions in the TUGx paper, 'Current Profiling: In a Class of Its Own' from 2022."}]}
{"messages": [{"role": "system", "content": "Question: What are the things I should be aware of when converting DCVI code to DCVS code?"}, {"role": "user", "content": "1. Because the UVI80 has a FSMAX of 1MHz and the UVS256-HP/64 has a FSMAX of 200kHz, the matter acquisition for a DCVI can be up to 5x faster than a DCVS for the same sample size settings. 2. DCVS requires the meter.filter.value to be larger than the user set sampling rate, which ensures there are no overlapping samples. The DCVI does not have this restriction however it is recommended to follow this same methodology for capturing a DC value. 3. The recommended best-practice for a single averaged result is to use hardware averaging and only 1 software sample. Therefore, the test code should use thehdw.DCVS.meter.filter.value or thehdw.DCVI.meter.hardwareaverage.value only to set the averaging size."}]}
{"messages": [{"role": "system", "content": "Question: On UltraFLEX platform, design an external instrument that can fast charge a smart phone."}, {"role": "user", "content": "Here is the overall block diagram of the external instrument core module. First of all, there is power amplifier with safety control. This power amplifier compensates the output error by feedback from the current monitor and the voltage monitor return value. Current monitor read the voltage value through serial sense resistor. Voltage monitor read the output voltage value through high voltage attenuator. These monitored feedback value which include error summing to feedback network and compensate to power amplifier output. There are several relays for multi function control. Basically there is output Kelvin connection relays for DUT connection. And internal Kelvin without DUT connection but connected internal home load resistor. There is fixed custom capacitor filter for user output characteristics. The power bank is getting power from ATE DC instrument input then store energy for forcing output. All input channels include analog and digital control pins are connected to ATE instrument channels. For the line drop issue of analog input reference, Kelvin connection is also applied to reference input to compensate line drop reference voltage. Digital channels are intended to enable control of analog powers and relay control drivers. Digital pins enable internal power charging for power bank and power amplifier activation. Relay driver can be work in several ways for our target interface. If our module interface is just one channel type, then relay driver input digital pins could be parallel type for time reduction. And if these module is bank type integrated several pins, then to minimize the input digital pin counts, MUX and buffer could be used for common pin sharing. Also serial digital protocol type could be used instead of full parallel protocol type."}]}
{"messages": [{"role": "system", "content": "Question: My RF measurement powers don't seem correct. I think I need to include the losses from the DIB. How do I do this?"}, {"role": "user", "content": "De-embedding in IG-XL is performed using a logical instrument called MWDIB. The values to be de-embedded are loaded into MWDIB either by hardcoding in VBT, or, preferably, by loading the values from file(s) at validation. When using files, MWDIB language is used to load s-parameters from an s2p file or scalar values from a csv. There is also an option to hardcode values on a per-frequency, per-path basis. When using s-parameters, .Fixture is used, and when using scalar values, .Gamma is used. The tool is able to use a single set of values or cascade multiple values along a path using the .SubFixture commands. The loaded files are then applied to the appropriate signals for de-embedding at runtime. One of the more difficult aspects of using MWDIB is the collecting of the data. There are many ways to obtain the data, but all of them have their tradeoffs. A few of these are: direct measurement, inferred measurement such as that found using automatic fixture removal using a network analyzer, simulation data for the DIB, spec sheet data for different components, data provided by the vendor such as for a specific cable, or correction factors found by comparing bench results to ATE results. Oftentimes the user will need to combine multiple sources of data by cascading S-parameters. Thankfully, MWDIB can do this for you. The steps are: 1) Collect all of the data available for the DIB. 2) Load the de-embedding data using .Fixture, .Gamma, or .Subfixture language node .Read command at validation. These files will likely be dependent on DIB id, site, and pin. A site and label can optionally be applied at this time. 3) Setup subfixture along a given path (be careful of the direction) 2) Enable MWDIB for the source and/or at runtime using TheHdw.MWDIB.Pins.Fixture.Enable 3) Verify that the correct value is applied and enabled using the Microwave Debug Display Tool."}]}
{"messages": [{"role": "system", "content": "Question: My test program uses a multitude of functional tests and the HSDP is close to running out of Vector Memory? What can I do to redesign my patterns to account for this use case?"}, {"role": "user", "content": "IG-XL includes memory efficiency features that can address this use case. You can: 1. Use the single-direction pin setups, which reduce the number of usable pin states and reduce the Vector Memory consumed by the pattern. These pin setups are input, output, 2x-input, and 2x-output. You can easily change these pin setups to existing compiled patterns in PatternTool. However, you can only change scan pins through a .atp file. 2. On UltraFLEXplus, you can use the Functional Vector Compression features. This includes the scan_start and scan_end microcodes, which allow for vertically formatted scan blocks that closer match the appearance of parallel vector data. This means you do not have to turn cycles into a scan chain and transposing the data. Using this syntax you can replace the states of pins that do not change throughout the scan block with a "-" character. This causes the pin to not consume memory for the duration of the scan block, minus the initial vector. You can also use Flexible Scan, which allows a scan block to use any subset of declared scan pins."}]}
{"messages": [{"role": "system", "content": "Question: My test results on UltraFLEXplus are not repeatable, and I believe there is too much variation in the time it takes to execute the test, due to variations in the speed of the Host PC or other processes in Windows. What can I do to make this more repeatable?"}, {"role": "user", "content": "There are a range of techniques available on UltraFLEXplus to apply, depending on the situation. If you are looking to make Device Power Up and Power Down more repeatable and predictable, implement the use of TheHdw.LevelsAndTiming.ApplyRepeatableSequence. If you are looking to synchronize multiple tester instruments to provide the DUT a stimulus and make measurements, this is best done using pattern microcodes within a digital pattern. Each of the UltraFLEXplus instruments supports a range of pattern microcodes that can be invoked within the digital pattern, as well as Parameter Sets (PSETs) and Signals language. This has the benefit of improving repeatability as well as providing optimized test times. Finally, if you have a solution in which VBT code must execute, such as cases where a digital pattern must handshake with code using Patgen CPU flags, you can define a Repeatable Code Sequence (RCS), using TheHdw.Sequence.Serial.Begin and End. This language takes advantage of the inherent repeatability of the UltraFLEXplus Distributed Multi Controllers (DMCs) by downloading all the code between the Begin and End statements to the DMCs before executing it. In one test case using Pin PMU measurements and Patgen CPU flags found that this reduced the variability of the time for the code to execute from 3ms to 0.125ms. There are a few documented restrictions to keep in mind when using this method, following the principle that the DMCs should not have to stop and wait for communication with the host PC or datalog processes during execution the RCS sequence."}]}
